/****************************************************************

  Generated by Eclipse Cyclone DDS IDL to CXX Translator
  File name: C:\DXEProjects\Tools\cyclonedds\build64\bin\Debug\SportModeState.idl
  Source: SportModeState.cpp
  Cyclone DDS: v0.11.0

*****************************************************************/
#include "SportModeState.hpp"

#include <org/eclipse/cyclonedds/util/ostream_operators.hpp>

namespace unitree_go
{
    namespace msg
    {
        namespace dds_
        {
            std::ostream& operator<<(std::ostream& os, TimeSpec_ const& rhs)
            {
                (void)rhs;
                os << "[";
                os << "sec: " << rhs.sec();
                os << ", nanosec: " << rhs.nanosec();
                os << "]";
                return os;
            }

            std::ostream& operator<<(std::ostream& os, PathPoint_ const& rhs)
            {
                (void)rhs;
                os << "[";
                os << "timeFromStart: " << rhs.timeFromStart();
                os << ", x: " << rhs.x();
                os << ", y: " << rhs.y();
                os << ", yaw: " << rhs.yaw();
                os << ", vx: " << rhs.vx();
                os << ", vy: " << rhs.vy();
                os << ", vyaw: " << rhs.vyaw();
                os << "]";
                return os;
            }

            std::ostream& operator<<(std::ostream& os, SportModeState_ const& rhs)
            {
                (void)rhs;
                os << "[";
                os << "stamp: " << rhs.stamp();
                os << ", error_code: " << rhs.error_code();
                os << ", imu_state: " << rhs.imu_state();
                os << ", mode: " << rhs.mode();
                os << ", progress: " << rhs.progress();
                os << ", gait_type: " << rhs.gait_type();
                os << ", foot_raise_height: " << rhs.foot_raise_height();
                os << ", position: " << rhs.position();
                os << ", body_height: " << rhs.body_height();
                os << ", velocity: " << rhs.velocity();
                os << ", yaw_speed: " << rhs.yaw_speed();
                os << ", range_obstacle: " << rhs.range_obstacle();
                os << ", foot_force: " << rhs.foot_force();
                os << ", foot_position_body: " << rhs.foot_position_body();
                os << ", foot_speed_body: " << rhs.foot_speed_body();
                os << ", path_point: " << rhs.path_point();
                os << "]";
                return os;
            }

        } //namespace dds_

    } //namespace msg

} //namespace unitree_go

namespace org {
    namespace eclipse {
        namespace cyclonedds {
            namespace core {
                namespace cdr {

                    template<>
                    const propvec& get_type_props<::unitree_go::msg::dds_::TimeSpec_>() {
                        static std::mutex mtx;
                        static propvec props;
                        static std::atomic_bool initialized{ false };
                        key_endpoint keylist;
                        if (initialized.load(std::memory_order_relaxed))
                            return props;
                        std::lock_guard<std::mutex> lock(mtx);
                        if (initialized.load(std::memory_order_relaxed))
                            return props;
                        props.clear();

                        props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
                        props.push_back(entity_properties_t(1, 0, false, get_bit_bound<int32_t>(), extensibility::ext_final, false));  //::sec
                        props.push_back(entity_properties_t(1, 1, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::nanosec

                        entity_properties_t::finish(props, keylist);
                        initialized.store(true, std::memory_order_release);
                        return props;
                    }

                    template<>
                    const propvec& get_type_props<::unitree_go::msg::dds_::PathPoint_>() {
                        static std::mutex mtx;
                        static propvec props;
                        static std::atomic_bool initialized{ false };
                        key_endpoint keylist;
                        if (initialized.load(std::memory_order_relaxed))
                            return props;
                        std::lock_guard<std::mutex> lock(mtx);
                        if (initialized.load(std::memory_order_relaxed))
                            return props;
                        props.clear();

                        props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
                        props.push_back(entity_properties_t(1, 0, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::timeFromStart
                        props.push_back(entity_properties_t(1, 1, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::x
                        props.push_back(entity_properties_t(1, 2, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::y
                        props.push_back(entity_properties_t(1, 3, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::yaw
                        props.push_back(entity_properties_t(1, 4, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::vx
                        props.push_back(entity_properties_t(1, 5, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::vy
                        props.push_back(entity_properties_t(1, 6, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::vyaw

                        entity_properties_t::finish(props, keylist);
                        initialized.store(true, std::memory_order_release);
                        return props;
                    }

                    template<>
                    const propvec& get_type_props<::unitree_go::msg::dds_::SportModeState_>() {
                        static std::mutex mtx;
                        static propvec props;
                        static std::atomic_bool initialized{ false };
                        key_endpoint keylist;
                        if (initialized.load(std::memory_order_relaxed))
                            return props;
                        std::lock_guard<std::mutex> lock(mtx);
                        if (initialized.load(std::memory_order_relaxed))
                            return props;
                        props.clear();

                        props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
                        props.push_back(entity_properties_t(1, 0, false, get_bit_bound<::unitree_go::msg::dds_::TimeSpec_>(), extensibility::ext_final, false));  //::stamp
                        entity_properties_t::append_struct_contents(props, get_type_props<::unitree_go::msg::dds_::TimeSpec_>());  //internal contents of ::stamp
                        props.push_back(entity_properties_t(1, 1, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::error_code
                        props.push_back(entity_properties_t(1, 2, false, get_bit_bound<::unitree_go::msg::dds_::IMUState_>(), extensibility::ext_final, false));  //::imu_state
                        entity_properties_t::append_struct_contents(props, get_type_props<::unitree_go::msg::dds_::IMUState_>());  //internal contents of ::imu_state
                        props.push_back(entity_properties_t(1, 3, false, get_bit_bound<uint8_t>(), extensibility::ext_final, false));  //::mode
                        props.push_back(entity_properties_t(1, 4, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::progress
                        props.push_back(entity_properties_t(1, 5, false, get_bit_bound<uint8_t>(), extensibility::ext_final, false));  //::gait_type
                        props.push_back(entity_properties_t(1, 6, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::foot_raise_height
                        props.push_back(entity_properties_t(1, 7, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::position
                        props.push_back(entity_properties_t(1, 8, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::body_height
                        props.push_back(entity_properties_t(1, 9, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::velocity
                        props.push_back(entity_properties_t(1, 10, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::yaw_speed
                        props.push_back(entity_properties_t(1, 11, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::range_obstacle
                        props.push_back(entity_properties_t(1, 12, false, get_bit_bound<int16_t>(), extensibility::ext_final, false));  //::foot_force
                        props.push_back(entity_properties_t(1, 13, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::foot_position_body
                        props.push_back(entity_properties_t(1, 14, false, get_bit_bound<float>(), extensibility::ext_final, false));  //::foot_speed_body
                        props.push_back(entity_properties_t(1, 15, false, get_bit_bound<::unitree_go::msg::dds_::PathPoint_>(), extensibility::ext_final, false));  //::path_point
                        entity_properties_t::append_struct_contents(props, get_type_props<::unitree_go::msg::dds_::PathPoint_>());  //internal contents of ::path_point

                        entity_properties_t::finish(props, keylist);
                        initialized.store(true, std::memory_order_release);
                        return props;
                    }

                } //namespace cdr
            } //namespace core
        } //namespace cyclonedds
    } //namespace eclipse
} //namespace org