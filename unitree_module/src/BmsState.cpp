/****************************************************************

  Generated by Eclipse Cyclone DDS IDL to CXX Translator
  File name: C:\DXEProjects\Tools\cyclonedds\build64\bin\Debug\BmsState.idl
  Source: BmsState.cpp
  Cyclone DDS: v0.11.0

*****************************************************************/
#include "BmsState.hpp"

#include <org/eclipse/cyclonedds/util/ostream_operators.hpp>

namespace unitree_go
{
    namespace msg
    {
        namespace dds_
        {
            std::ostream& operator<<(std::ostream& os, BmsState_ const& rhs)
            {
                (void)rhs;
                os << "[";
                os << "version_high: " << rhs.version_high();
                os << ", version_low: " << rhs.version_low();
                os << ", status: " << rhs.status();
                os << ", soc: " << rhs.soc();
                os << ", current: " << rhs.current();
                os << ", cycle: " << rhs.cycle();
                os << ", bq_ntc: " << rhs.bq_ntc();
                os << ", mcu_ntc: " << rhs.mcu_ntc();
                os << ", cell_vol: " << rhs.cell_vol();
                os << "]";
                return os;
            }

        } //namespace dds_

    } //namespace msg

} //namespace unitree_go

namespace org {
    namespace eclipse {
        namespace cyclonedds {
            namespace core {
                namespace cdr {

                    template<>
                    const propvec& get_type_props<::unitree_go::msg::dds_::BmsState_>() {
                        static std::mutex mtx;
                        static propvec props;
                        static std::atomic_bool initialized{ false };
                        key_endpoint keylist;
                        if (initialized.load(std::memory_order_relaxed))
                            return props;
                        std::lock_guard<std::mutex> lock(mtx);
                        if (initialized.load(std::memory_order_relaxed))
                            return props;
                        props.clear();

                        props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
                        props.push_back(entity_properties_t(1, 0, false, get_bit_bound<uint8_t>(), extensibility::ext_final, false));  //::version_high
                        props.push_back(entity_properties_t(1, 1, false, get_bit_bound<uint8_t>(), extensibility::ext_final, false));  //::version_low
                        props.push_back(entity_properties_t(1, 2, false, get_bit_bound<uint8_t>(), extensibility::ext_final, false));  //::status
                        props.push_back(entity_properties_t(1, 3, false, get_bit_bound<uint8_t>(), extensibility::ext_final, false));  //::soc
                        props.push_back(entity_properties_t(1, 4, false, get_bit_bound<int32_t>(), extensibility::ext_final, false));  //::current
                        props.push_back(entity_properties_t(1, 5, false, get_bit_bound<uint16_t>(), extensibility::ext_final, false));  //::cycle
                        props.push_back(entity_properties_t(1, 6, false, get_bit_bound<uint8_t>(), extensibility::ext_final, false));  //::bq_ntc
                        props.push_back(entity_properties_t(1, 7, false, get_bit_bound<uint8_t>(), extensibility::ext_final, false));  //::mcu_ntc
                        props.push_back(entity_properties_t(1, 8, false, get_bit_bound<uint16_t>(), extensibility::ext_final, false));  //::cell_vol

                        entity_properties_t::finish(props, keylist);
                        initialized.store(true, std::memory_order_release);
                        return props;
                    }

                } //namespace cdr
            } //namespace core
        } //namespace cyclonedds
    } //namespace eclipse
} //namespace org